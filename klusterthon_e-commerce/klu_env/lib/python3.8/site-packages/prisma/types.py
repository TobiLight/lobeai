# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = Literal['default', 'insensitive']
SortOrder = Literal['asc', 'desc']

MetricsFormat = Literal['json', 'prometheus']


class _DatasourceOverrideOptional(TypedDict, total=False):
    env: str
    name: str


class DatasourceOverride(_DatasourceOverrideOptional):
    url: str


# NOTE: we don't support some options as their type hints are not publicly exposed
# https://github.com/encode/httpx/discussions/1977
class HttpConfig(TypedDict, total=False):
    app: Callable[[Mapping[str, Any], Any], Any]
    http1: bool
    http2: bool
    limits: httpx.Limits
    timeout: Union[None, float, httpx.Timeout]
    trust_env: bool
    max_redirects: int


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# User types

class UserOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the User create method"""
    first_name: Optional[_str]
    last_name: Optional[_str]
    conversations: 'ConversationCreateManyNestedWithoutRelationsInput'
    database_connections: 'DatabaseConnectionCreateManyNestedWithoutRelationsInput'
    created_at: datetime.datetime
    updated_at: datetime.datetime


class UserCreateInput(UserOptionalCreateInput):
    """Required arguments to the User create method"""
    id: _str
    email: _str
    password: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the User create method, without relations"""
    first_name: Optional[_str]
    last_name: Optional[_str]
    created_at: datetime.datetime
    updated_at: datetime.datetime


class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
    """Required arguments to the User create method, without relations"""
    id: _str
    email: _str
    password: _str


class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'


class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
    connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]


_UserWhereUnique_id_Input = TypedDict(
    '_UserWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_UserWhereUnique_email_Input = TypedDict(
    '_UserWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

UserWhereUniqueInput = Union[
    '_UserWhereUnique_id_Input',
    '_UserWhereUnique_email_Input',
]


class UserUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    first_name: Optional[_str]
    last_name: Optional[_str]
    email: _str
    password: _str
    conversations: 'ConversationUpdateManyWithoutRelationsInput'
    database_connections: 'DatabaseConnectionUpdateManyWithoutRelationsInput'
    created_at: datetime.datetime
    updated_at: datetime.datetime


class UserUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    first_name: Optional[_str]
    last_name: Optional[_str]
    email: _str
    password: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserCreateWithoutRelationsInput']
    connect: List['UserWhereUniqueInput']
    set: List['UserWhereUniqueInput']
    disconnect: List['UserWhereUniqueInput']
    delete: List['UserWhereUniqueInput']

    # TODO
    # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserScalarWhereInput']
    # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['UserCreateOrConnectWithoutRelationsInput']


class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserUpdateInput'
    # upsert: 'UserUpsertWithoutRelationsInput'
    # connectOrCreate: 'UserCreateOrConnectWithoutRelationsInput'


class UserUpsertInput(TypedDict):
    create: 'UserCreateInput'
    update: 'UserUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_User_id_OrderByInput = TypedDict(
    '_User_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_User_first_name_OrderByInput = TypedDict(
    '_User_first_name_OrderByInput',
    {
        'first_name': 'SortOrder',
    },
    total=True
)

_User_last_name_OrderByInput = TypedDict(
    '_User_last_name_OrderByInput',
    {
        'last_name': 'SortOrder',
    },
    total=True
)

_User_email_OrderByInput = TypedDict(
    '_User_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_User_password_OrderByInput = TypedDict(
    '_User_password_OrderByInput',
    {
        'password': 'SortOrder',
    },
    total=True
)

_User_created_at_OrderByInput = TypedDict(
    '_User_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_User_updated_at_OrderByInput = TypedDict(
    '_User_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

UserOrderByInput = Union[
    '_User_id_OrderByInput',
    '_User_first_name_OrderByInput',
    '_User_last_name_OrderByInput',
    '_User_email_OrderByInput',
    '_User_password_OrderByInput',
    '_User_created_at_OrderByInput',
    '_User_updated_at_OrderByInput',
]



# recursive User types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

UserRelationFilter = TypedDict(
    'UserRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class UserListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class UserInclude(TypedDict, total=False):
    """User relational arguments"""
    conversations: Union[bool, 'FindManyConversationArgsFromUser']
    database_connections: Union[bool, 'FindManyDatabaseConnectionArgsFromUser']


    

class UserIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    conversations: Union[bool, 'FindManyConversationArgsFromUserRecursive1']
    database_connections: Union[bool, 'FindManyDatabaseConnectionArgsFromUserRecursive1']


class UserIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    conversations: Union[bool, 'FindManyConversationArgsFromUserRecursive2']
    database_connections: Union[bool, 'FindManyDatabaseConnectionArgsFromUserRecursive2']


class UserIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    conversations: Union[bool, 'FindManyConversationArgsFromUserRecursive3']
    database_connections: Union[bool, 'FindManyDatabaseConnectionArgsFromUserRecursive3']


class UserIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    conversations: Union[bool, 'FindManyConversationArgsFromUserRecursive4']
    database_connections: Union[bool, 'FindManyDatabaseConnectionArgsFromUserRecursive4']


class UserIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class UserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyUserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class ConversationIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    prompts: Union[bool, 'FindManyPromptArgsFromUserRecursive1']
    user: Union[bool, 'UserArgsFromUserRecursive1']


class ConversationIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    prompts: Union[bool, 'FindManyPromptArgsFromUserRecursive2']
    user: Union[bool, 'UserArgsFromUserRecursive2']


class ConversationIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    prompts: Union[bool, 'FindManyPromptArgsFromUserRecursive3']
    user: Union[bool, 'UserArgsFromUserRecursive3']


class ConversationIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    prompts: Union[bool, 'FindManyPromptArgsFromUserRecursive4']
    user: Union[bool, 'UserArgsFromUserRecursive4']


class ConversationIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class ConversationArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ConversationIncludeFromConversationRecursive1'


class ConversationArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'ConversationIncludeFromConversationRecursive2'


class ConversationArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'ConversationIncludeFromConversationRecursive3'


class ConversationArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'ConversationIncludeFromConversationRecursive4'


class ConversationArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyConversationArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversationRecursive1'


class FindManyConversationArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversationRecursive2'


class FindManyConversationArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversationRecursive3'


class FindManyConversationArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversationRecursive4'


class FindManyConversationArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    
    

class PromptIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    conversation: Union[bool, 'ConversationArgsFromUserRecursive1']


class PromptIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    conversation: Union[bool, 'ConversationArgsFromUserRecursive2']


class PromptIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    conversation: Union[bool, 'ConversationArgsFromUserRecursive3']


class PromptIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    conversation: Union[bool, 'ConversationArgsFromUserRecursive4']


class PromptIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class PromptArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'PromptIncludeFromPromptRecursive1'


class PromptArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'PromptIncludeFromPromptRecursive2'


class PromptArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'PromptIncludeFromPromptRecursive3'


class PromptArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'PromptIncludeFromPromptRecursive4'


class PromptArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyPromptArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    include: 'PromptIncludeFromPromptRecursive1'


class FindManyPromptArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    include: 'PromptIncludeFromPromptRecursive2'


class FindManyPromptArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    include: 'PromptIncludeFromPromptRecursive3'


class FindManyPromptArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    include: 'PromptIncludeFromPromptRecursive4'


class FindManyPromptArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    
    

class DatabaseConnectionIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive1']


class DatabaseConnectionIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive2']


class DatabaseConnectionIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive3']


class DatabaseConnectionIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive4']


class DatabaseConnectionIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class DatabaseConnectionArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive1'


class DatabaseConnectionArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive2'


class DatabaseConnectionArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive3'


class DatabaseConnectionArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive4'


class DatabaseConnectionArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyDatabaseConnectionArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive1'


class FindManyDatabaseConnectionArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive2'


class FindManyDatabaseConnectionArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive3'


class FindManyDatabaseConnectionArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive4'


class FindManyDatabaseConnectionArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    


FindManyUserArgs = FindManyUserArgsFromUser
FindFirstUserArgs = FindManyUserArgsFromUser


    

class UserWhereInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    first_name: Union[None, _str, 'types.StringFilter']
    last_name: Union[None, _str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    conversations: 'ConversationListRelationFilter'
    database_connections: 'DatabaseConnectionListRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive1', List['UserWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive1']
    OR: List['UserWhereInputRecursive1']
    NOT: List['UserWhereInputRecursive1']


class UserWhereInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    first_name: Union[None, _str, 'types.StringFilter']
    last_name: Union[None, _str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    conversations: 'ConversationListRelationFilter'
    database_connections: 'DatabaseConnectionListRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive2', List['UserWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive2']
    OR: List['UserWhereInputRecursive2']
    NOT: List['UserWhereInputRecursive2']


class UserWhereInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    first_name: Union[None, _str, 'types.StringFilter']
    last_name: Union[None, _str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    conversations: 'ConversationListRelationFilter'
    database_connections: 'DatabaseConnectionListRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive3', List['UserWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive3']
    OR: List['UserWhereInputRecursive3']
    NOT: List['UserWhereInputRecursive3']


class UserWhereInputRecursive3(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    first_name: Union[None, _str, 'types.StringFilter']
    last_name: Union[None, _str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    conversations: 'ConversationListRelationFilter'
    database_connections: 'DatabaseConnectionListRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive4', List['UserWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive4']
    OR: List['UserWhereInputRecursive4']
    NOT: List['UserWhereInputRecursive4']


class UserWhereInputRecursive4(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    first_name: Union[None, _str, 'types.StringFilter']
    last_name: Union[None, _str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    conversations: 'ConversationListRelationFilter'
    database_connections: 'DatabaseConnectionListRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate User types


    

class UserScalarWhereWithAggregatesInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    first_name: Union[_str, 'types.StringWithAggregatesFilter']
    last_name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive1']
    OR: List['UserScalarWhereWithAggregatesInputRecursive1']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive1']


class UserScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    first_name: Union[_str, 'types.StringWithAggregatesFilter']
    last_name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive2']
    OR: List['UserScalarWhereWithAggregatesInputRecursive2']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive2']


class UserScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    first_name: Union[_str, 'types.StringWithAggregatesFilter']
    last_name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive3']
    OR: List['UserScalarWhereWithAggregatesInputRecursive3']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive3']


class UserScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    first_name: Union[_str, 'types.StringWithAggregatesFilter']
    last_name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive4']
    OR: List['UserScalarWhereWithAggregatesInputRecursive4']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive4']


class UserScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    first_name: Union[_str, 'types.StringWithAggregatesFilter']
    last_name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class UserGroupByOutput(TypedDict, total=False):
    id: _str
    first_name: _str
    last_name: _str
    email: _str
    password: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    _sum: 'UserSumAggregateOutput'
    _avg: 'UserAvgAggregateOutput'
    _min: 'UserMinAggregateOutput'
    _max: 'UserMaxAggregateOutput'
    _count: 'UserCountAggregateOutput'


class UserAvgAggregateOutput(TypedDict, total=False):
    """User output for aggregating averages"""


class UserSumAggregateOutput(TypedDict, total=False):
    """User output for aggregating sums"""


class UserScalarAggregateOutput(TypedDict, total=False):
    """User output including scalar fields"""
    id: _str
    first_name: _str
    last_name: _str
    email: _str
    password: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


UserMinAggregateOutput = UserScalarAggregateOutput
UserMaxAggregateOutput = UserScalarAggregateOutput


class UserMaxAggregateInput(TypedDict, total=False):
    """User input for aggregating by max"""
    id: bool
    first_name: bool
    last_name: bool
    email: bool
    password: bool
    created_at: bool
    updated_at: bool


class UserMinAggregateInput(TypedDict, total=False):
    """User input for aggregating by min"""
    id: bool
    first_name: bool
    last_name: bool
    email: bool
    password: bool
    created_at: bool
    updated_at: bool


class UserNumberAggregateInput(TypedDict, total=False):
    """User input for aggregating numbers"""


UserAvgAggregateInput = UserNumberAggregateInput
UserSumAggregateInput = UserNumberAggregateInput


UserCountAggregateInput = TypedDict(
    'UserCountAggregateInput',
    {
        'id': bool,
        'first_name': bool,
        'last_name': bool,
        'email': bool,
        'password': bool,
        'created_at': bool,
        'updated_at': bool,
        '_all': bool,
    },
    total=False,
)

UserCountAggregateOutput = TypedDict(
    'UserCountAggregateOutput',
    {
        'id': int,
        'first_name': int,
        'last_name': int,
        'email': int,
        'password': int,
        'created_at': int,
        'updated_at': int,
        '_all': int,
    },
    total=False,
)


UserKeys = Literal[
    'id',
    'first_name',
    'last_name',
    'email',
    'password',
    'conversations',
    'database_connections',
    'created_at',
    'updated_at',
]
UserScalarFieldKeys = Literal[
    'id',
    'first_name',
    'last_name',
    'email',
    'password',
    'created_at',
    'updated_at',
]
UserScalarFieldKeysT = TypeVar('UserScalarFieldKeysT', bound=UserScalarFieldKeys)

UserRelationalFieldKeys = Literal[
        'conversations',
        'database_connections',
    ]

# Conversation types

class ConversationOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Conversation create method"""
    prompts: 'PromptCreateManyNestedWithoutRelationsInput'
    user_id: _str
    user: 'UserCreateNestedWithoutRelationsInput'
    created_at: datetime.datetime
    updated_at: datetime.datetime


class ConversationCreateInput(ConversationOptionalCreateInput):
    """Required arguments to the Conversation create method"""
    id: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ConversationOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Conversation create method, without relations"""
    user_id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class ConversationCreateWithoutRelationsInput(ConversationOptionalCreateWithoutRelationsInput):
    """Required arguments to the Conversation create method, without relations"""
    id: _str


class ConversationCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ConversationCreateWithoutRelationsInput'
    connect: 'ConversationWhereUniqueInput'


class ConversationCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ConversationCreateWithoutRelationsInput', List['ConversationCreateWithoutRelationsInput']]
    connect: Union['ConversationWhereUniqueInput', List['ConversationWhereUniqueInput']]


_ConversationWhereUnique_id_Input = TypedDict(
    '_ConversationWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

ConversationWhereUniqueInput = _ConversationWhereUnique_id_Input


class ConversationUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    prompts: 'PromptUpdateManyWithoutRelationsInput'
    user: 'UserUpdateOneWithoutRelationsInput'
    created_at: datetime.datetime
    updated_at: datetime.datetime


class ConversationUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class ConversationUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ConversationCreateWithoutRelationsInput']
    connect: List['ConversationWhereUniqueInput']
    set: List['ConversationWhereUniqueInput']
    disconnect: List['ConversationWhereUniqueInput']
    delete: List['ConversationWhereUniqueInput']

    # TODO
    # update: List['ConversationUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ConversationUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ConversationScalarWhereInput']
    # upsert: List['ConversationUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['ConversationCreateOrConnectWithoutRelationsInput']


class ConversationUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ConversationCreateWithoutRelationsInput'
    connect: 'ConversationWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ConversationUpdateInput'
    # upsert: 'ConversationUpsertWithoutRelationsInput'
    # connectOrCreate: 'ConversationCreateOrConnectWithoutRelationsInput'


class ConversationUpsertInput(TypedDict):
    create: 'ConversationCreateInput'
    update: 'ConversationUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Conversation_id_OrderByInput = TypedDict(
    '_Conversation_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Conversation_user_id_OrderByInput = TypedDict(
    '_Conversation_user_id_OrderByInput',
    {
        'user_id': 'SortOrder',
    },
    total=True
)

_Conversation_created_at_OrderByInput = TypedDict(
    '_Conversation_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Conversation_updated_at_OrderByInput = TypedDict(
    '_Conversation_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

ConversationOrderByInput = Union[
    '_Conversation_id_OrderByInput',
    '_Conversation_user_id_OrderByInput',
    '_Conversation_created_at_OrderByInput',
    '_Conversation_updated_at_OrderByInput',
]



# recursive Conversation types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ConversationRelationFilter = TypedDict(
    'ConversationRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class ConversationListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class ConversationInclude(TypedDict, total=False):
    """Conversation relational arguments"""
    prompts: Union[bool, 'FindManyPromptArgsFromConversation']
    user: Union[bool, 'UserArgsFromConversation']


    

class UserIncludeFromConversation(TypedDict, total=False):
    """Relational arguments for Conversation"""
    conversations: Union[bool, 'FindManyConversationArgsFromConversationRecursive1']
    database_connections: Union[bool, 'FindManyDatabaseConnectionArgsFromConversationRecursive1']


class UserIncludeFromConversationRecursive1(TypedDict, total=False):
    """Relational arguments for Conversation"""
    conversations: Union[bool, 'FindManyConversationArgsFromConversationRecursive2']
    database_connections: Union[bool, 'FindManyDatabaseConnectionArgsFromConversationRecursive2']


class UserIncludeFromConversationRecursive2(TypedDict, total=False):
    """Relational arguments for Conversation"""
    conversations: Union[bool, 'FindManyConversationArgsFromConversationRecursive3']
    database_connections: Union[bool, 'FindManyDatabaseConnectionArgsFromConversationRecursive3']


class UserIncludeFromConversationRecursive3(TypedDict, total=False):
    """Relational arguments for Conversation"""
    conversations: Union[bool, 'FindManyConversationArgsFromConversationRecursive4']
    database_connections: Union[bool, 'FindManyDatabaseConnectionArgsFromConversationRecursive4']


class UserIncludeFromConversationRecursive4(TypedDict, total=False):
    """Relational arguments for Conversation"""

    

class UserArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromConversationRecursive1(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromConversationRecursive2(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromConversationRecursive3(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromConversationRecursive4(TypedDict, total=False):
    """Arguments for Conversation"""
    
    

class FindManyUserArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromConversationRecursive1(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromConversationRecursive2(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromConversationRecursive3(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromConversationRecursive4(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class ConversationIncludeFromConversation(TypedDict, total=False):
    """Relational arguments for Conversation"""
    prompts: Union[bool, 'FindManyPromptArgsFromConversationRecursive1']
    user: Union[bool, 'UserArgsFromConversationRecursive1']


class ConversationIncludeFromConversationRecursive1(TypedDict, total=False):
    """Relational arguments for Conversation"""
    prompts: Union[bool, 'FindManyPromptArgsFromConversationRecursive2']
    user: Union[bool, 'UserArgsFromConversationRecursive2']


class ConversationIncludeFromConversationRecursive2(TypedDict, total=False):
    """Relational arguments for Conversation"""
    prompts: Union[bool, 'FindManyPromptArgsFromConversationRecursive3']
    user: Union[bool, 'UserArgsFromConversationRecursive3']


class ConversationIncludeFromConversationRecursive3(TypedDict, total=False):
    """Relational arguments for Conversation"""
    prompts: Union[bool, 'FindManyPromptArgsFromConversationRecursive4']
    user: Union[bool, 'UserArgsFromConversationRecursive4']


class ConversationIncludeFromConversationRecursive4(TypedDict, total=False):
    """Relational arguments for Conversation"""

    

class ConversationArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'ConversationIncludeFromConversationRecursive1'


class ConversationArgsFromConversationRecursive1(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'ConversationIncludeFromConversationRecursive2'


class ConversationArgsFromConversationRecursive2(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'ConversationIncludeFromConversationRecursive3'


class ConversationArgsFromConversationRecursive3(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'ConversationIncludeFromConversationRecursive4'


class ConversationArgsFromConversationRecursive4(TypedDict, total=False):
    """Arguments for Conversation"""
    
    

class FindManyConversationArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversationRecursive1'


class FindManyConversationArgsFromConversationRecursive1(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversationRecursive2'


class FindManyConversationArgsFromConversationRecursive2(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversationRecursive3'


class FindManyConversationArgsFromConversationRecursive3(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversationRecursive4'


class FindManyConversationArgsFromConversationRecursive4(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    
    

class PromptIncludeFromConversation(TypedDict, total=False):
    """Relational arguments for Conversation"""
    conversation: Union[bool, 'ConversationArgsFromConversationRecursive1']


class PromptIncludeFromConversationRecursive1(TypedDict, total=False):
    """Relational arguments for Conversation"""
    conversation: Union[bool, 'ConversationArgsFromConversationRecursive2']


class PromptIncludeFromConversationRecursive2(TypedDict, total=False):
    """Relational arguments for Conversation"""
    conversation: Union[bool, 'ConversationArgsFromConversationRecursive3']


class PromptIncludeFromConversationRecursive3(TypedDict, total=False):
    """Relational arguments for Conversation"""
    conversation: Union[bool, 'ConversationArgsFromConversationRecursive4']


class PromptIncludeFromConversationRecursive4(TypedDict, total=False):
    """Relational arguments for Conversation"""

    

class PromptArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'PromptIncludeFromPromptRecursive1'


class PromptArgsFromConversationRecursive1(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'PromptIncludeFromPromptRecursive2'


class PromptArgsFromConversationRecursive2(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'PromptIncludeFromPromptRecursive3'


class PromptArgsFromConversationRecursive3(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'PromptIncludeFromPromptRecursive4'


class PromptArgsFromConversationRecursive4(TypedDict, total=False):
    """Arguments for Conversation"""
    
    

class FindManyPromptArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    include: 'PromptIncludeFromPromptRecursive1'


class FindManyPromptArgsFromConversationRecursive1(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    include: 'PromptIncludeFromPromptRecursive2'


class FindManyPromptArgsFromConversationRecursive2(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    include: 'PromptIncludeFromPromptRecursive3'


class FindManyPromptArgsFromConversationRecursive3(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    include: 'PromptIncludeFromPromptRecursive4'


class FindManyPromptArgsFromConversationRecursive4(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    
    

class DatabaseConnectionIncludeFromConversation(TypedDict, total=False):
    """Relational arguments for Conversation"""
    user: Union[bool, 'UserArgsFromConversationRecursive1']


class DatabaseConnectionIncludeFromConversationRecursive1(TypedDict, total=False):
    """Relational arguments for Conversation"""
    user: Union[bool, 'UserArgsFromConversationRecursive2']


class DatabaseConnectionIncludeFromConversationRecursive2(TypedDict, total=False):
    """Relational arguments for Conversation"""
    user: Union[bool, 'UserArgsFromConversationRecursive3']


class DatabaseConnectionIncludeFromConversationRecursive3(TypedDict, total=False):
    """Relational arguments for Conversation"""
    user: Union[bool, 'UserArgsFromConversationRecursive4']


class DatabaseConnectionIncludeFromConversationRecursive4(TypedDict, total=False):
    """Relational arguments for Conversation"""

    

class DatabaseConnectionArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive1'


class DatabaseConnectionArgsFromConversationRecursive1(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive2'


class DatabaseConnectionArgsFromConversationRecursive2(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive3'


class DatabaseConnectionArgsFromConversationRecursive3(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive4'


class DatabaseConnectionArgsFromConversationRecursive4(TypedDict, total=False):
    """Arguments for Conversation"""
    
    

class FindManyDatabaseConnectionArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive1'


class FindManyDatabaseConnectionArgsFromConversationRecursive1(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive2'


class FindManyDatabaseConnectionArgsFromConversationRecursive2(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive3'


class FindManyDatabaseConnectionArgsFromConversationRecursive3(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive4'


class FindManyDatabaseConnectionArgsFromConversationRecursive4(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    


FindManyConversationArgs = FindManyConversationArgsFromConversation
FindFirstConversationArgs = FindManyConversationArgsFromConversation


    

class ConversationWhereInput(TypedDict, total=False):
    """Conversation arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    prompts: 'PromptListRelationFilter'
    user_id: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ConversationWhereInputRecursive1', List['ConversationWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['ConversationWhereInputRecursive1']
    OR: List['ConversationWhereInputRecursive1']
    NOT: List['ConversationWhereInputRecursive1']


class ConversationWhereInputRecursive1(TypedDict, total=False):
    """Conversation arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    prompts: 'PromptListRelationFilter'
    user_id: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ConversationWhereInputRecursive2', List['ConversationWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['ConversationWhereInputRecursive2']
    OR: List['ConversationWhereInputRecursive2']
    NOT: List['ConversationWhereInputRecursive2']


class ConversationWhereInputRecursive2(TypedDict, total=False):
    """Conversation arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    prompts: 'PromptListRelationFilter'
    user_id: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ConversationWhereInputRecursive3', List['ConversationWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['ConversationWhereInputRecursive3']
    OR: List['ConversationWhereInputRecursive3']
    NOT: List['ConversationWhereInputRecursive3']


class ConversationWhereInputRecursive3(TypedDict, total=False):
    """Conversation arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    prompts: 'PromptListRelationFilter'
    user_id: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ConversationWhereInputRecursive4', List['ConversationWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['ConversationWhereInputRecursive4']
    OR: List['ConversationWhereInputRecursive4']
    NOT: List['ConversationWhereInputRecursive4']


class ConversationWhereInputRecursive4(TypedDict, total=False):
    """Conversation arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    prompts: 'PromptListRelationFilter'
    user_id: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate Conversation types


    

class ConversationScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Conversation arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ConversationScalarWhereWithAggregatesInputRecursive1']
    OR: List['ConversationScalarWhereWithAggregatesInputRecursive1']
    NOT: List['ConversationScalarWhereWithAggregatesInputRecursive1']


class ConversationScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Conversation arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ConversationScalarWhereWithAggregatesInputRecursive2']
    OR: List['ConversationScalarWhereWithAggregatesInputRecursive2']
    NOT: List['ConversationScalarWhereWithAggregatesInputRecursive2']


class ConversationScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Conversation arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ConversationScalarWhereWithAggregatesInputRecursive3']
    OR: List['ConversationScalarWhereWithAggregatesInputRecursive3']
    NOT: List['ConversationScalarWhereWithAggregatesInputRecursive3']


class ConversationScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Conversation arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ConversationScalarWhereWithAggregatesInputRecursive4']
    OR: List['ConversationScalarWhereWithAggregatesInputRecursive4']
    NOT: List['ConversationScalarWhereWithAggregatesInputRecursive4']


class ConversationScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Conversation arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class ConversationGroupByOutput(TypedDict, total=False):
    id: _str
    user_id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    _sum: 'ConversationSumAggregateOutput'
    _avg: 'ConversationAvgAggregateOutput'
    _min: 'ConversationMinAggregateOutput'
    _max: 'ConversationMaxAggregateOutput'
    _count: 'ConversationCountAggregateOutput'


class ConversationAvgAggregateOutput(TypedDict, total=False):
    """Conversation output for aggregating averages"""


class ConversationSumAggregateOutput(TypedDict, total=False):
    """Conversation output for aggregating sums"""


class ConversationScalarAggregateOutput(TypedDict, total=False):
    """Conversation output including scalar fields"""
    id: _str
    user_id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


ConversationMinAggregateOutput = ConversationScalarAggregateOutput
ConversationMaxAggregateOutput = ConversationScalarAggregateOutput


class ConversationMaxAggregateInput(TypedDict, total=False):
    """Conversation input for aggregating by max"""
    id: bool
    user_id: bool
    created_at: bool
    updated_at: bool


class ConversationMinAggregateInput(TypedDict, total=False):
    """Conversation input for aggregating by min"""
    id: bool
    user_id: bool
    created_at: bool
    updated_at: bool


class ConversationNumberAggregateInput(TypedDict, total=False):
    """Conversation input for aggregating numbers"""


ConversationAvgAggregateInput = ConversationNumberAggregateInput
ConversationSumAggregateInput = ConversationNumberAggregateInput


ConversationCountAggregateInput = TypedDict(
    'ConversationCountAggregateInput',
    {
        'id': bool,
        'user_id': bool,
        'created_at': bool,
        'updated_at': bool,
        '_all': bool,
    },
    total=False,
)

ConversationCountAggregateOutput = TypedDict(
    'ConversationCountAggregateOutput',
    {
        'id': int,
        'user_id': int,
        'created_at': int,
        'updated_at': int,
        '_all': int,
    },
    total=False,
)


ConversationKeys = Literal[
    'id',
    'prompts',
    'user_id',
    'user',
    'created_at',
    'updated_at',
]
ConversationScalarFieldKeys = Literal[
    'id',
    'user_id',
    'created_at',
    'updated_at',
]
ConversationScalarFieldKeysT = TypeVar('ConversationScalarFieldKeysT', bound=ConversationScalarFieldKeys)

ConversationRelationalFieldKeys = Literal[
        'prompts',
        'user',
    ]

# Prompt types

class PromptOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Prompt create method"""
    conversation_id: _str
    conversation: 'ConversationCreateNestedWithoutRelationsInput'
    created_at: datetime.datetime
    updated_at: datetime.datetime


class PromptCreateInput(PromptOptionalCreateInput):
    """Required arguments to the Prompt create method"""
    id: _str
    query: _str
    response: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PromptOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Prompt create method, without relations"""
    conversation_id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class PromptCreateWithoutRelationsInput(PromptOptionalCreateWithoutRelationsInput):
    """Required arguments to the Prompt create method, without relations"""
    id: _str
    query: _str
    response: _str


class PromptCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PromptCreateWithoutRelationsInput'
    connect: 'PromptWhereUniqueInput'


class PromptCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PromptCreateWithoutRelationsInput', List['PromptCreateWithoutRelationsInput']]
    connect: Union['PromptWhereUniqueInput', List['PromptWhereUniqueInput']]


_PromptWhereUnique_id_Input = TypedDict(
    '_PromptWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

PromptWhereUniqueInput = _PromptWhereUnique_id_Input


class PromptUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    query: _str
    response: _str
    conversation: 'ConversationUpdateOneWithoutRelationsInput'
    created_at: datetime.datetime
    updated_at: datetime.datetime


class PromptUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    query: _str
    response: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class PromptUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PromptCreateWithoutRelationsInput']
    connect: List['PromptWhereUniqueInput']
    set: List['PromptWhereUniqueInput']
    disconnect: List['PromptWhereUniqueInput']
    delete: List['PromptWhereUniqueInput']

    # TODO
    # update: List['PromptUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PromptUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PromptScalarWhereInput']
    # upsert: List['PromptUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['PromptCreateOrConnectWithoutRelationsInput']


class PromptUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PromptCreateWithoutRelationsInput'
    connect: 'PromptWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PromptUpdateInput'
    # upsert: 'PromptUpsertWithoutRelationsInput'
    # connectOrCreate: 'PromptCreateOrConnectWithoutRelationsInput'


class PromptUpsertInput(TypedDict):
    create: 'PromptCreateInput'
    update: 'PromptUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Prompt_id_OrderByInput = TypedDict(
    '_Prompt_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Prompt_query_OrderByInput = TypedDict(
    '_Prompt_query_OrderByInput',
    {
        'query': 'SortOrder',
    },
    total=True
)

_Prompt_response_OrderByInput = TypedDict(
    '_Prompt_response_OrderByInput',
    {
        'response': 'SortOrder',
    },
    total=True
)

_Prompt_conversation_id_OrderByInput = TypedDict(
    '_Prompt_conversation_id_OrderByInput',
    {
        'conversation_id': 'SortOrder',
    },
    total=True
)

_Prompt_created_at_OrderByInput = TypedDict(
    '_Prompt_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Prompt_updated_at_OrderByInput = TypedDict(
    '_Prompt_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

PromptOrderByInput = Union[
    '_Prompt_id_OrderByInput',
    '_Prompt_query_OrderByInput',
    '_Prompt_response_OrderByInput',
    '_Prompt_conversation_id_OrderByInput',
    '_Prompt_created_at_OrderByInput',
    '_Prompt_updated_at_OrderByInput',
]



# recursive Prompt types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

PromptRelationFilter = TypedDict(
    'PromptRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class PromptListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class PromptInclude(TypedDict, total=False):
    """Prompt relational arguments"""
    conversation: Union[bool, 'ConversationArgsFromPrompt']


    

class UserIncludeFromPrompt(TypedDict, total=False):
    """Relational arguments for Prompt"""
    conversations: Union[bool, 'FindManyConversationArgsFromPromptRecursive1']
    database_connections: Union[bool, 'FindManyDatabaseConnectionArgsFromPromptRecursive1']


class UserIncludeFromPromptRecursive1(TypedDict, total=False):
    """Relational arguments for Prompt"""
    conversations: Union[bool, 'FindManyConversationArgsFromPromptRecursive2']
    database_connections: Union[bool, 'FindManyDatabaseConnectionArgsFromPromptRecursive2']


class UserIncludeFromPromptRecursive2(TypedDict, total=False):
    """Relational arguments for Prompt"""
    conversations: Union[bool, 'FindManyConversationArgsFromPromptRecursive3']
    database_connections: Union[bool, 'FindManyDatabaseConnectionArgsFromPromptRecursive3']


class UserIncludeFromPromptRecursive3(TypedDict, total=False):
    """Relational arguments for Prompt"""
    conversations: Union[bool, 'FindManyConversationArgsFromPromptRecursive4']
    database_connections: Union[bool, 'FindManyDatabaseConnectionArgsFromPromptRecursive4']


class UserIncludeFromPromptRecursive4(TypedDict, total=False):
    """Relational arguments for Prompt"""

    

class UserArgsFromPrompt(TypedDict, total=False):
    """Arguments for Prompt"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromPromptRecursive1(TypedDict, total=False):
    """Arguments for Prompt"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromPromptRecursive2(TypedDict, total=False):
    """Arguments for Prompt"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromPromptRecursive3(TypedDict, total=False):
    """Arguments for Prompt"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromPromptRecursive4(TypedDict, total=False):
    """Arguments for Prompt"""
    
    

class FindManyUserArgsFromPrompt(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromPromptRecursive1(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromPromptRecursive2(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromPromptRecursive3(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromPromptRecursive4(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class ConversationIncludeFromPrompt(TypedDict, total=False):
    """Relational arguments for Prompt"""
    prompts: Union[bool, 'FindManyPromptArgsFromPromptRecursive1']
    user: Union[bool, 'UserArgsFromPromptRecursive1']


class ConversationIncludeFromPromptRecursive1(TypedDict, total=False):
    """Relational arguments for Prompt"""
    prompts: Union[bool, 'FindManyPromptArgsFromPromptRecursive2']
    user: Union[bool, 'UserArgsFromPromptRecursive2']


class ConversationIncludeFromPromptRecursive2(TypedDict, total=False):
    """Relational arguments for Prompt"""
    prompts: Union[bool, 'FindManyPromptArgsFromPromptRecursive3']
    user: Union[bool, 'UserArgsFromPromptRecursive3']


class ConversationIncludeFromPromptRecursive3(TypedDict, total=False):
    """Relational arguments for Prompt"""
    prompts: Union[bool, 'FindManyPromptArgsFromPromptRecursive4']
    user: Union[bool, 'UserArgsFromPromptRecursive4']


class ConversationIncludeFromPromptRecursive4(TypedDict, total=False):
    """Relational arguments for Prompt"""

    

class ConversationArgsFromPrompt(TypedDict, total=False):
    """Arguments for Prompt"""
    include: 'ConversationIncludeFromConversationRecursive1'


class ConversationArgsFromPromptRecursive1(TypedDict, total=False):
    """Arguments for Prompt"""
    include: 'ConversationIncludeFromConversationRecursive2'


class ConversationArgsFromPromptRecursive2(TypedDict, total=False):
    """Arguments for Prompt"""
    include: 'ConversationIncludeFromConversationRecursive3'


class ConversationArgsFromPromptRecursive3(TypedDict, total=False):
    """Arguments for Prompt"""
    include: 'ConversationIncludeFromConversationRecursive4'


class ConversationArgsFromPromptRecursive4(TypedDict, total=False):
    """Arguments for Prompt"""
    
    

class FindManyConversationArgsFromPrompt(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversationRecursive1'


class FindManyConversationArgsFromPromptRecursive1(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversationRecursive2'


class FindManyConversationArgsFromPromptRecursive2(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversationRecursive3'


class FindManyConversationArgsFromPromptRecursive3(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversationRecursive4'


class FindManyConversationArgsFromPromptRecursive4(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    
    

class PromptIncludeFromPrompt(TypedDict, total=False):
    """Relational arguments for Prompt"""
    conversation: Union[bool, 'ConversationArgsFromPromptRecursive1']


class PromptIncludeFromPromptRecursive1(TypedDict, total=False):
    """Relational arguments for Prompt"""
    conversation: Union[bool, 'ConversationArgsFromPromptRecursive2']


class PromptIncludeFromPromptRecursive2(TypedDict, total=False):
    """Relational arguments for Prompt"""
    conversation: Union[bool, 'ConversationArgsFromPromptRecursive3']


class PromptIncludeFromPromptRecursive3(TypedDict, total=False):
    """Relational arguments for Prompt"""
    conversation: Union[bool, 'ConversationArgsFromPromptRecursive4']


class PromptIncludeFromPromptRecursive4(TypedDict, total=False):
    """Relational arguments for Prompt"""

    

class PromptArgsFromPrompt(TypedDict, total=False):
    """Arguments for Prompt"""
    include: 'PromptIncludeFromPromptRecursive1'


class PromptArgsFromPromptRecursive1(TypedDict, total=False):
    """Arguments for Prompt"""
    include: 'PromptIncludeFromPromptRecursive2'


class PromptArgsFromPromptRecursive2(TypedDict, total=False):
    """Arguments for Prompt"""
    include: 'PromptIncludeFromPromptRecursive3'


class PromptArgsFromPromptRecursive3(TypedDict, total=False):
    """Arguments for Prompt"""
    include: 'PromptIncludeFromPromptRecursive4'


class PromptArgsFromPromptRecursive4(TypedDict, total=False):
    """Arguments for Prompt"""
    
    

class FindManyPromptArgsFromPrompt(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    include: 'PromptIncludeFromPromptRecursive1'


class FindManyPromptArgsFromPromptRecursive1(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    include: 'PromptIncludeFromPromptRecursive2'


class FindManyPromptArgsFromPromptRecursive2(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    include: 'PromptIncludeFromPromptRecursive3'


class FindManyPromptArgsFromPromptRecursive3(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    include: 'PromptIncludeFromPromptRecursive4'


class FindManyPromptArgsFromPromptRecursive4(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    
    

class DatabaseConnectionIncludeFromPrompt(TypedDict, total=False):
    """Relational arguments for Prompt"""
    user: Union[bool, 'UserArgsFromPromptRecursive1']


class DatabaseConnectionIncludeFromPromptRecursive1(TypedDict, total=False):
    """Relational arguments for Prompt"""
    user: Union[bool, 'UserArgsFromPromptRecursive2']


class DatabaseConnectionIncludeFromPromptRecursive2(TypedDict, total=False):
    """Relational arguments for Prompt"""
    user: Union[bool, 'UserArgsFromPromptRecursive3']


class DatabaseConnectionIncludeFromPromptRecursive3(TypedDict, total=False):
    """Relational arguments for Prompt"""
    user: Union[bool, 'UserArgsFromPromptRecursive4']


class DatabaseConnectionIncludeFromPromptRecursive4(TypedDict, total=False):
    """Relational arguments for Prompt"""

    

class DatabaseConnectionArgsFromPrompt(TypedDict, total=False):
    """Arguments for Prompt"""
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive1'


class DatabaseConnectionArgsFromPromptRecursive1(TypedDict, total=False):
    """Arguments for Prompt"""
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive2'


class DatabaseConnectionArgsFromPromptRecursive2(TypedDict, total=False):
    """Arguments for Prompt"""
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive3'


class DatabaseConnectionArgsFromPromptRecursive3(TypedDict, total=False):
    """Arguments for Prompt"""
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive4'


class DatabaseConnectionArgsFromPromptRecursive4(TypedDict, total=False):
    """Arguments for Prompt"""
    
    

class FindManyDatabaseConnectionArgsFromPrompt(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive1'


class FindManyDatabaseConnectionArgsFromPromptRecursive1(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive2'


class FindManyDatabaseConnectionArgsFromPromptRecursive2(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive3'


class FindManyDatabaseConnectionArgsFromPromptRecursive3(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive4'


class FindManyDatabaseConnectionArgsFromPromptRecursive4(TypedDict, total=False):
    """Arguments for Prompt"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    


FindManyPromptArgs = FindManyPromptArgsFromPrompt
FindFirstPromptArgs = FindManyPromptArgsFromPrompt


    

class PromptWhereInput(TypedDict, total=False):
    """Prompt arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    query: Union[_str, 'types.StringFilter']
    response: Union[_str, 'types.StringFilter']
    conversation_id: Union[_str, 'types.StringFilter']
    conversation: 'ConversationRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['PromptWhereInputRecursive1', List['PromptWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['PromptWhereInputRecursive1']
    OR: List['PromptWhereInputRecursive1']
    NOT: List['PromptWhereInputRecursive1']


class PromptWhereInputRecursive1(TypedDict, total=False):
    """Prompt arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    query: Union[_str, 'types.StringFilter']
    response: Union[_str, 'types.StringFilter']
    conversation_id: Union[_str, 'types.StringFilter']
    conversation: 'ConversationRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['PromptWhereInputRecursive2', List['PromptWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['PromptWhereInputRecursive2']
    OR: List['PromptWhereInputRecursive2']
    NOT: List['PromptWhereInputRecursive2']


class PromptWhereInputRecursive2(TypedDict, total=False):
    """Prompt arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    query: Union[_str, 'types.StringFilter']
    response: Union[_str, 'types.StringFilter']
    conversation_id: Union[_str, 'types.StringFilter']
    conversation: 'ConversationRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['PromptWhereInputRecursive3', List['PromptWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['PromptWhereInputRecursive3']
    OR: List['PromptWhereInputRecursive3']
    NOT: List['PromptWhereInputRecursive3']


class PromptWhereInputRecursive3(TypedDict, total=False):
    """Prompt arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    query: Union[_str, 'types.StringFilter']
    response: Union[_str, 'types.StringFilter']
    conversation_id: Union[_str, 'types.StringFilter']
    conversation: 'ConversationRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['PromptWhereInputRecursive4', List['PromptWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['PromptWhereInputRecursive4']
    OR: List['PromptWhereInputRecursive4']
    NOT: List['PromptWhereInputRecursive4']


class PromptWhereInputRecursive4(TypedDict, total=False):
    """Prompt arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    query: Union[_str, 'types.StringFilter']
    response: Union[_str, 'types.StringFilter']
    conversation_id: Union[_str, 'types.StringFilter']
    conversation: 'ConversationRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate Prompt types


    

class PromptScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Prompt arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    query: Union[_str, 'types.StringWithAggregatesFilter']
    response: Union[_str, 'types.StringWithAggregatesFilter']
    conversation_id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PromptScalarWhereWithAggregatesInputRecursive1']
    OR: List['PromptScalarWhereWithAggregatesInputRecursive1']
    NOT: List['PromptScalarWhereWithAggregatesInputRecursive1']


class PromptScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Prompt arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    query: Union[_str, 'types.StringWithAggregatesFilter']
    response: Union[_str, 'types.StringWithAggregatesFilter']
    conversation_id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PromptScalarWhereWithAggregatesInputRecursive2']
    OR: List['PromptScalarWhereWithAggregatesInputRecursive2']
    NOT: List['PromptScalarWhereWithAggregatesInputRecursive2']


class PromptScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Prompt arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    query: Union[_str, 'types.StringWithAggregatesFilter']
    response: Union[_str, 'types.StringWithAggregatesFilter']
    conversation_id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PromptScalarWhereWithAggregatesInputRecursive3']
    OR: List['PromptScalarWhereWithAggregatesInputRecursive3']
    NOT: List['PromptScalarWhereWithAggregatesInputRecursive3']


class PromptScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Prompt arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    query: Union[_str, 'types.StringWithAggregatesFilter']
    response: Union[_str, 'types.StringWithAggregatesFilter']
    conversation_id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PromptScalarWhereWithAggregatesInputRecursive4']
    OR: List['PromptScalarWhereWithAggregatesInputRecursive4']
    NOT: List['PromptScalarWhereWithAggregatesInputRecursive4']


class PromptScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Prompt arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    query: Union[_str, 'types.StringWithAggregatesFilter']
    response: Union[_str, 'types.StringWithAggregatesFilter']
    conversation_id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class PromptGroupByOutput(TypedDict, total=False):
    id: _str
    query: _str
    response: _str
    conversation_id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    _sum: 'PromptSumAggregateOutput'
    _avg: 'PromptAvgAggregateOutput'
    _min: 'PromptMinAggregateOutput'
    _max: 'PromptMaxAggregateOutput'
    _count: 'PromptCountAggregateOutput'


class PromptAvgAggregateOutput(TypedDict, total=False):
    """Prompt output for aggregating averages"""


class PromptSumAggregateOutput(TypedDict, total=False):
    """Prompt output for aggregating sums"""


class PromptScalarAggregateOutput(TypedDict, total=False):
    """Prompt output including scalar fields"""
    id: _str
    query: _str
    response: _str
    conversation_id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


PromptMinAggregateOutput = PromptScalarAggregateOutput
PromptMaxAggregateOutput = PromptScalarAggregateOutput


class PromptMaxAggregateInput(TypedDict, total=False):
    """Prompt input for aggregating by max"""
    id: bool
    query: bool
    response: bool
    conversation_id: bool
    created_at: bool
    updated_at: bool


class PromptMinAggregateInput(TypedDict, total=False):
    """Prompt input for aggregating by min"""
    id: bool
    query: bool
    response: bool
    conversation_id: bool
    created_at: bool
    updated_at: bool


class PromptNumberAggregateInput(TypedDict, total=False):
    """Prompt input for aggregating numbers"""


PromptAvgAggregateInput = PromptNumberAggregateInput
PromptSumAggregateInput = PromptNumberAggregateInput


PromptCountAggregateInput = TypedDict(
    'PromptCountAggregateInput',
    {
        'id': bool,
        'query': bool,
        'response': bool,
        'conversation_id': bool,
        'created_at': bool,
        'updated_at': bool,
        '_all': bool,
    },
    total=False,
)

PromptCountAggregateOutput = TypedDict(
    'PromptCountAggregateOutput',
    {
        'id': int,
        'query': int,
        'response': int,
        'conversation_id': int,
        'created_at': int,
        'updated_at': int,
        '_all': int,
    },
    total=False,
)


PromptKeys = Literal[
    'id',
    'query',
    'response',
    'conversation_id',
    'conversation',
    'created_at',
    'updated_at',
]
PromptScalarFieldKeys = Literal[
    'id',
    'query',
    'response',
    'conversation_id',
    'created_at',
    'updated_at',
]
PromptScalarFieldKeysT = TypeVar('PromptScalarFieldKeysT', bound=PromptScalarFieldKeys)

PromptRelationalFieldKeys = Literal[
        'conversation',
    ]

# DatabaseConnection types

class DatabaseConnectionOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the DatabaseConnection create method"""
    user_id: _str
    user: 'UserCreateNestedWithoutRelationsInput'
    created_at: datetime.datetime
    updated_at: datetime.datetime


class DatabaseConnectionCreateInput(DatabaseConnectionOptionalCreateInput):
    """Required arguments to the DatabaseConnection create method"""
    id: _str
    type: _str
    uri: _str
    username: _str
    password: _str
    host: _str
    port: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class DatabaseConnectionOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the DatabaseConnection create method, without relations"""
    user_id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class DatabaseConnectionCreateWithoutRelationsInput(DatabaseConnectionOptionalCreateWithoutRelationsInput):
    """Required arguments to the DatabaseConnection create method, without relations"""
    id: _str
    type: _str
    uri: _str
    username: _str
    password: _str
    host: _str
    port: _str


class DatabaseConnectionCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'DatabaseConnectionCreateWithoutRelationsInput'
    connect: 'DatabaseConnectionWhereUniqueInput'


class DatabaseConnectionCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['DatabaseConnectionCreateWithoutRelationsInput', List['DatabaseConnectionCreateWithoutRelationsInput']]
    connect: Union['DatabaseConnectionWhereUniqueInput', List['DatabaseConnectionWhereUniqueInput']]


_DatabaseConnectionWhereUnique_id_Input = TypedDict(
    '_DatabaseConnectionWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

DatabaseConnectionWhereUniqueInput = _DatabaseConnectionWhereUnique_id_Input


class DatabaseConnectionUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    type: _str
    uri: _str
    username: _str
    password: _str
    host: _str
    port: _str
    user: 'UserUpdateOneWithoutRelationsInput'
    created_at: datetime.datetime
    updated_at: datetime.datetime


class DatabaseConnectionUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    type: _str
    uri: _str
    username: _str
    password: _str
    host: _str
    port: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class DatabaseConnectionUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['DatabaseConnectionCreateWithoutRelationsInput']
    connect: List['DatabaseConnectionWhereUniqueInput']
    set: List['DatabaseConnectionWhereUniqueInput']
    disconnect: List['DatabaseConnectionWhereUniqueInput']
    delete: List['DatabaseConnectionWhereUniqueInput']

    # TODO
    # update: List['DatabaseConnectionUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['DatabaseConnectionUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['DatabaseConnectionScalarWhereInput']
    # upsert: List['DatabaseConnectionUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['DatabaseConnectionCreateOrConnectWithoutRelationsInput']


class DatabaseConnectionUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'DatabaseConnectionCreateWithoutRelationsInput'
    connect: 'DatabaseConnectionWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'DatabaseConnectionUpdateInput'
    # upsert: 'DatabaseConnectionUpsertWithoutRelationsInput'
    # connectOrCreate: 'DatabaseConnectionCreateOrConnectWithoutRelationsInput'


class DatabaseConnectionUpsertInput(TypedDict):
    create: 'DatabaseConnectionCreateInput'
    update: 'DatabaseConnectionUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_DatabaseConnection_id_OrderByInput = TypedDict(
    '_DatabaseConnection_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_DatabaseConnection_type_OrderByInput = TypedDict(
    '_DatabaseConnection_type_OrderByInput',
    {
        'type': 'SortOrder',
    },
    total=True
)

_DatabaseConnection_uri_OrderByInput = TypedDict(
    '_DatabaseConnection_uri_OrderByInput',
    {
        'uri': 'SortOrder',
    },
    total=True
)

_DatabaseConnection_username_OrderByInput = TypedDict(
    '_DatabaseConnection_username_OrderByInput',
    {
        'username': 'SortOrder',
    },
    total=True
)

_DatabaseConnection_password_OrderByInput = TypedDict(
    '_DatabaseConnection_password_OrderByInput',
    {
        'password': 'SortOrder',
    },
    total=True
)

_DatabaseConnection_host_OrderByInput = TypedDict(
    '_DatabaseConnection_host_OrderByInput',
    {
        'host': 'SortOrder',
    },
    total=True
)

_DatabaseConnection_port_OrderByInput = TypedDict(
    '_DatabaseConnection_port_OrderByInput',
    {
        'port': 'SortOrder',
    },
    total=True
)

_DatabaseConnection_user_id_OrderByInput = TypedDict(
    '_DatabaseConnection_user_id_OrderByInput',
    {
        'user_id': 'SortOrder',
    },
    total=True
)

_DatabaseConnection_created_at_OrderByInput = TypedDict(
    '_DatabaseConnection_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_DatabaseConnection_updated_at_OrderByInput = TypedDict(
    '_DatabaseConnection_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

DatabaseConnectionOrderByInput = Union[
    '_DatabaseConnection_id_OrderByInput',
    '_DatabaseConnection_type_OrderByInput',
    '_DatabaseConnection_uri_OrderByInput',
    '_DatabaseConnection_username_OrderByInput',
    '_DatabaseConnection_password_OrderByInput',
    '_DatabaseConnection_host_OrderByInput',
    '_DatabaseConnection_port_OrderByInput',
    '_DatabaseConnection_user_id_OrderByInput',
    '_DatabaseConnection_created_at_OrderByInput',
    '_DatabaseConnection_updated_at_OrderByInput',
]



# recursive DatabaseConnection types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

DatabaseConnectionRelationFilter = TypedDict(
    'DatabaseConnectionRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class DatabaseConnectionListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class DatabaseConnectionInclude(TypedDict, total=False):
    """DatabaseConnection relational arguments"""
    user: Union[bool, 'UserArgsFromDatabaseConnection']


    

class UserIncludeFromDatabaseConnection(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""
    conversations: Union[bool, 'FindManyConversationArgsFromDatabaseConnectionRecursive1']
    database_connections: Union[bool, 'FindManyDatabaseConnectionArgsFromDatabaseConnectionRecursive1']


class UserIncludeFromDatabaseConnectionRecursive1(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""
    conversations: Union[bool, 'FindManyConversationArgsFromDatabaseConnectionRecursive2']
    database_connections: Union[bool, 'FindManyDatabaseConnectionArgsFromDatabaseConnectionRecursive2']


class UserIncludeFromDatabaseConnectionRecursive2(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""
    conversations: Union[bool, 'FindManyConversationArgsFromDatabaseConnectionRecursive3']
    database_connections: Union[bool, 'FindManyDatabaseConnectionArgsFromDatabaseConnectionRecursive3']


class UserIncludeFromDatabaseConnectionRecursive3(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""
    conversations: Union[bool, 'FindManyConversationArgsFromDatabaseConnectionRecursive4']
    database_connections: Union[bool, 'FindManyDatabaseConnectionArgsFromDatabaseConnectionRecursive4']


class UserIncludeFromDatabaseConnectionRecursive4(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""

    

class UserArgsFromDatabaseConnection(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromDatabaseConnectionRecursive1(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromDatabaseConnectionRecursive2(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromDatabaseConnectionRecursive3(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromDatabaseConnectionRecursive4(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    
    

class FindManyUserArgsFromDatabaseConnection(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromDatabaseConnectionRecursive1(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromDatabaseConnectionRecursive2(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromDatabaseConnectionRecursive3(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromDatabaseConnectionRecursive4(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class ConversationIncludeFromDatabaseConnection(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""
    prompts: Union[bool, 'FindManyPromptArgsFromDatabaseConnectionRecursive1']
    user: Union[bool, 'UserArgsFromDatabaseConnectionRecursive1']


class ConversationIncludeFromDatabaseConnectionRecursive1(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""
    prompts: Union[bool, 'FindManyPromptArgsFromDatabaseConnectionRecursive2']
    user: Union[bool, 'UserArgsFromDatabaseConnectionRecursive2']


class ConversationIncludeFromDatabaseConnectionRecursive2(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""
    prompts: Union[bool, 'FindManyPromptArgsFromDatabaseConnectionRecursive3']
    user: Union[bool, 'UserArgsFromDatabaseConnectionRecursive3']


class ConversationIncludeFromDatabaseConnectionRecursive3(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""
    prompts: Union[bool, 'FindManyPromptArgsFromDatabaseConnectionRecursive4']
    user: Union[bool, 'UserArgsFromDatabaseConnectionRecursive4']


class ConversationIncludeFromDatabaseConnectionRecursive4(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""

    

class ConversationArgsFromDatabaseConnection(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    include: 'ConversationIncludeFromConversationRecursive1'


class ConversationArgsFromDatabaseConnectionRecursive1(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    include: 'ConversationIncludeFromConversationRecursive2'


class ConversationArgsFromDatabaseConnectionRecursive2(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    include: 'ConversationIncludeFromConversationRecursive3'


class ConversationArgsFromDatabaseConnectionRecursive3(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    include: 'ConversationIncludeFromConversationRecursive4'


class ConversationArgsFromDatabaseConnectionRecursive4(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    
    

class FindManyConversationArgsFromDatabaseConnection(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversationRecursive1'


class FindManyConversationArgsFromDatabaseConnectionRecursive1(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversationRecursive2'


class FindManyConversationArgsFromDatabaseConnectionRecursive2(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversationRecursive3'


class FindManyConversationArgsFromDatabaseConnectionRecursive3(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversationRecursive4'


class FindManyConversationArgsFromDatabaseConnectionRecursive4(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    
    

class PromptIncludeFromDatabaseConnection(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""
    conversation: Union[bool, 'ConversationArgsFromDatabaseConnectionRecursive1']


class PromptIncludeFromDatabaseConnectionRecursive1(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""
    conversation: Union[bool, 'ConversationArgsFromDatabaseConnectionRecursive2']


class PromptIncludeFromDatabaseConnectionRecursive2(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""
    conversation: Union[bool, 'ConversationArgsFromDatabaseConnectionRecursive3']


class PromptIncludeFromDatabaseConnectionRecursive3(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""
    conversation: Union[bool, 'ConversationArgsFromDatabaseConnectionRecursive4']


class PromptIncludeFromDatabaseConnectionRecursive4(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""

    

class PromptArgsFromDatabaseConnection(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    include: 'PromptIncludeFromPromptRecursive1'


class PromptArgsFromDatabaseConnectionRecursive1(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    include: 'PromptIncludeFromPromptRecursive2'


class PromptArgsFromDatabaseConnectionRecursive2(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    include: 'PromptIncludeFromPromptRecursive3'


class PromptArgsFromDatabaseConnectionRecursive3(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    include: 'PromptIncludeFromPromptRecursive4'


class PromptArgsFromDatabaseConnectionRecursive4(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    
    

class FindManyPromptArgsFromDatabaseConnection(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    include: 'PromptIncludeFromPromptRecursive1'


class FindManyPromptArgsFromDatabaseConnectionRecursive1(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    include: 'PromptIncludeFromPromptRecursive2'


class FindManyPromptArgsFromDatabaseConnectionRecursive2(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    include: 'PromptIncludeFromPromptRecursive3'


class FindManyPromptArgsFromDatabaseConnectionRecursive3(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    include: 'PromptIncludeFromPromptRecursive4'


class FindManyPromptArgsFromDatabaseConnectionRecursive4(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['PromptOrderByInput', List['PromptOrderByInput']]
    where: 'PromptWhereInput'
    cursor: 'PromptWhereUniqueInput'
    distinct: List['PromptScalarFieldKeys']
    
    

class DatabaseConnectionIncludeFromDatabaseConnection(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""
    user: Union[bool, 'UserArgsFromDatabaseConnectionRecursive1']


class DatabaseConnectionIncludeFromDatabaseConnectionRecursive1(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""
    user: Union[bool, 'UserArgsFromDatabaseConnectionRecursive2']


class DatabaseConnectionIncludeFromDatabaseConnectionRecursive2(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""
    user: Union[bool, 'UserArgsFromDatabaseConnectionRecursive3']


class DatabaseConnectionIncludeFromDatabaseConnectionRecursive3(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""
    user: Union[bool, 'UserArgsFromDatabaseConnectionRecursive4']


class DatabaseConnectionIncludeFromDatabaseConnectionRecursive4(TypedDict, total=False):
    """Relational arguments for DatabaseConnection"""

    

class DatabaseConnectionArgsFromDatabaseConnection(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive1'


class DatabaseConnectionArgsFromDatabaseConnectionRecursive1(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive2'


class DatabaseConnectionArgsFromDatabaseConnectionRecursive2(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive3'


class DatabaseConnectionArgsFromDatabaseConnectionRecursive3(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive4'


class DatabaseConnectionArgsFromDatabaseConnectionRecursive4(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    
    

class FindManyDatabaseConnectionArgsFromDatabaseConnection(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive1'


class FindManyDatabaseConnectionArgsFromDatabaseConnectionRecursive1(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive2'


class FindManyDatabaseConnectionArgsFromDatabaseConnectionRecursive2(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive3'


class FindManyDatabaseConnectionArgsFromDatabaseConnectionRecursive3(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    include: 'DatabaseConnectionIncludeFromDatabaseConnectionRecursive4'


class FindManyDatabaseConnectionArgsFromDatabaseConnectionRecursive4(TypedDict, total=False):
    """Arguments for DatabaseConnection"""
    take: int
    skip: int
    order_by: Union['DatabaseConnectionOrderByInput', List['DatabaseConnectionOrderByInput']]
    where: 'DatabaseConnectionWhereInput'
    cursor: 'DatabaseConnectionWhereUniqueInput'
    distinct: List['DatabaseConnectionScalarFieldKeys']
    


FindManyDatabaseConnectionArgs = FindManyDatabaseConnectionArgsFromDatabaseConnection
FindFirstDatabaseConnectionArgs = FindManyDatabaseConnectionArgsFromDatabaseConnection


    

class DatabaseConnectionWhereInput(TypedDict, total=False):
    """DatabaseConnection arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    type: Union[_str, 'types.StringFilter']
    uri: Union[_str, 'types.StringFilter']
    username: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    host: Union[_str, 'types.StringFilter']
    port: Union[_str, 'types.StringFilter']
    user_id: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['DatabaseConnectionWhereInputRecursive1', List['DatabaseConnectionWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['DatabaseConnectionWhereInputRecursive1']
    OR: List['DatabaseConnectionWhereInputRecursive1']
    NOT: List['DatabaseConnectionWhereInputRecursive1']


class DatabaseConnectionWhereInputRecursive1(TypedDict, total=False):
    """DatabaseConnection arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    type: Union[_str, 'types.StringFilter']
    uri: Union[_str, 'types.StringFilter']
    username: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    host: Union[_str, 'types.StringFilter']
    port: Union[_str, 'types.StringFilter']
    user_id: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['DatabaseConnectionWhereInputRecursive2', List['DatabaseConnectionWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['DatabaseConnectionWhereInputRecursive2']
    OR: List['DatabaseConnectionWhereInputRecursive2']
    NOT: List['DatabaseConnectionWhereInputRecursive2']


class DatabaseConnectionWhereInputRecursive2(TypedDict, total=False):
    """DatabaseConnection arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    type: Union[_str, 'types.StringFilter']
    uri: Union[_str, 'types.StringFilter']
    username: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    host: Union[_str, 'types.StringFilter']
    port: Union[_str, 'types.StringFilter']
    user_id: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['DatabaseConnectionWhereInputRecursive3', List['DatabaseConnectionWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['DatabaseConnectionWhereInputRecursive3']
    OR: List['DatabaseConnectionWhereInputRecursive3']
    NOT: List['DatabaseConnectionWhereInputRecursive3']


class DatabaseConnectionWhereInputRecursive3(TypedDict, total=False):
    """DatabaseConnection arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    type: Union[_str, 'types.StringFilter']
    uri: Union[_str, 'types.StringFilter']
    username: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    host: Union[_str, 'types.StringFilter']
    port: Union[_str, 'types.StringFilter']
    user_id: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['DatabaseConnectionWhereInputRecursive4', List['DatabaseConnectionWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['DatabaseConnectionWhereInputRecursive4']
    OR: List['DatabaseConnectionWhereInputRecursive4']
    NOT: List['DatabaseConnectionWhereInputRecursive4']


class DatabaseConnectionWhereInputRecursive4(TypedDict, total=False):
    """DatabaseConnection arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    type: Union[_str, 'types.StringFilter']
    uri: Union[_str, 'types.StringFilter']
    username: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    host: Union[_str, 'types.StringFilter']
    port: Union[_str, 'types.StringFilter']
    user_id: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate DatabaseConnection types


    

class DatabaseConnectionScalarWhereWithAggregatesInput(TypedDict, total=False):
    """DatabaseConnection arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    uri: Union[_str, 'types.StringWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    host: Union[_str, 'types.StringWithAggregatesFilter']
    port: Union[_str, 'types.StringWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['DatabaseConnectionScalarWhereWithAggregatesInputRecursive1']
    OR: List['DatabaseConnectionScalarWhereWithAggregatesInputRecursive1']
    NOT: List['DatabaseConnectionScalarWhereWithAggregatesInputRecursive1']


class DatabaseConnectionScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """DatabaseConnection arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    uri: Union[_str, 'types.StringWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    host: Union[_str, 'types.StringWithAggregatesFilter']
    port: Union[_str, 'types.StringWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['DatabaseConnectionScalarWhereWithAggregatesInputRecursive2']
    OR: List['DatabaseConnectionScalarWhereWithAggregatesInputRecursive2']
    NOT: List['DatabaseConnectionScalarWhereWithAggregatesInputRecursive2']


class DatabaseConnectionScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """DatabaseConnection arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    uri: Union[_str, 'types.StringWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    host: Union[_str, 'types.StringWithAggregatesFilter']
    port: Union[_str, 'types.StringWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['DatabaseConnectionScalarWhereWithAggregatesInputRecursive3']
    OR: List['DatabaseConnectionScalarWhereWithAggregatesInputRecursive3']
    NOT: List['DatabaseConnectionScalarWhereWithAggregatesInputRecursive3']


class DatabaseConnectionScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """DatabaseConnection arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    uri: Union[_str, 'types.StringWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    host: Union[_str, 'types.StringWithAggregatesFilter']
    port: Union[_str, 'types.StringWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['DatabaseConnectionScalarWhereWithAggregatesInputRecursive4']
    OR: List['DatabaseConnectionScalarWhereWithAggregatesInputRecursive4']
    NOT: List['DatabaseConnectionScalarWhereWithAggregatesInputRecursive4']


class DatabaseConnectionScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """DatabaseConnection arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    uri: Union[_str, 'types.StringWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    host: Union[_str, 'types.StringWithAggregatesFilter']
    port: Union[_str, 'types.StringWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class DatabaseConnectionGroupByOutput(TypedDict, total=False):
    id: _str
    type: _str
    uri: _str
    username: _str
    password: _str
    host: _str
    port: _str
    user_id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    _sum: 'DatabaseConnectionSumAggregateOutput'
    _avg: 'DatabaseConnectionAvgAggregateOutput'
    _min: 'DatabaseConnectionMinAggregateOutput'
    _max: 'DatabaseConnectionMaxAggregateOutput'
    _count: 'DatabaseConnectionCountAggregateOutput'


class DatabaseConnectionAvgAggregateOutput(TypedDict, total=False):
    """DatabaseConnection output for aggregating averages"""


class DatabaseConnectionSumAggregateOutput(TypedDict, total=False):
    """DatabaseConnection output for aggregating sums"""


class DatabaseConnectionScalarAggregateOutput(TypedDict, total=False):
    """DatabaseConnection output including scalar fields"""
    id: _str
    type: _str
    uri: _str
    username: _str
    password: _str
    host: _str
    port: _str
    user_id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


DatabaseConnectionMinAggregateOutput = DatabaseConnectionScalarAggregateOutput
DatabaseConnectionMaxAggregateOutput = DatabaseConnectionScalarAggregateOutput


class DatabaseConnectionMaxAggregateInput(TypedDict, total=False):
    """DatabaseConnection input for aggregating by max"""
    id: bool
    type: bool
    uri: bool
    username: bool
    password: bool
    host: bool
    port: bool
    user_id: bool
    created_at: bool
    updated_at: bool


class DatabaseConnectionMinAggregateInput(TypedDict, total=False):
    """DatabaseConnection input for aggregating by min"""
    id: bool
    type: bool
    uri: bool
    username: bool
    password: bool
    host: bool
    port: bool
    user_id: bool
    created_at: bool
    updated_at: bool


class DatabaseConnectionNumberAggregateInput(TypedDict, total=False):
    """DatabaseConnection input for aggregating numbers"""


DatabaseConnectionAvgAggregateInput = DatabaseConnectionNumberAggregateInput
DatabaseConnectionSumAggregateInput = DatabaseConnectionNumberAggregateInput


DatabaseConnectionCountAggregateInput = TypedDict(
    'DatabaseConnectionCountAggregateInput',
    {
        'id': bool,
        'type': bool,
        'uri': bool,
        'username': bool,
        'password': bool,
        'host': bool,
        'port': bool,
        'user_id': bool,
        'created_at': bool,
        'updated_at': bool,
        '_all': bool,
    },
    total=False,
)

DatabaseConnectionCountAggregateOutput = TypedDict(
    'DatabaseConnectionCountAggregateOutput',
    {
        'id': int,
        'type': int,
        'uri': int,
        'username': int,
        'password': int,
        'host': int,
        'port': int,
        'user_id': int,
        'created_at': int,
        'updated_at': int,
        '_all': int,
    },
    total=False,
)


DatabaseConnectionKeys = Literal[
    'id',
    'type',
    'uri',
    'username',
    'password',
    'host',
    'port',
    'user_id',
    'user',
    'created_at',
    'updated_at',
]
DatabaseConnectionScalarFieldKeys = Literal[
    'id',
    'type',
    'uri',
    'username',
    'password',
    'host',
    'port',
    'user_id',
    'created_at',
    'updated_at',
]
DatabaseConnectionScalarFieldKeysT = TypeVar('DatabaseConnectionScalarFieldKeysT', bound=DatabaseConnectionScalarFieldKeys)

DatabaseConnectionRelationalFieldKeys = Literal[
        'user',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields